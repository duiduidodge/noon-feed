generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model Source {
  id        String    @id @default(cuid())
  name      String
  type      SourceType
  url       String    @unique
  enabled   Boolean   @default(true)
  category  String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  articles  Article[]

  @@index([enabled])
  @@index([type])
}

enum SourceType {
  RSS
  API
  MANUAL
}

model Article {
  id                 String       @id @default(cuid())
  sourceId           String
  source             Source       @relation(fields: [sourceId], references: [id])
  originalSourceName String?      // Original outlet name from API (CNBC, Crypto.news, etc.)
  url                String
  urlNormalized      String       @unique
  titleOriginal      String
  publishedAt        DateTime?
  fetchedAt          DateTime     @default(now())
  rawHtml            String?
  extractedText      String?
  hash               String       @unique
  language           String?      @default("en")
  status             ArticleStatus @default(PENDING)
  impactScore        Decimal?     @db.Decimal(3,2)  // Pre-filter impact score 0.00-1.00
  preFilterPassed    Boolean      @default(false)   // Whether article passed impact filter
  searchVectorEn     Unsupported("tsvector")?  @map("search_vector_en")  // Full-text search vector
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt
  enrichment         Enrichment?
  postings           Posting[]

  @@index([sourceId])
  @@index([publishedAt])
  @@index([status])
  @@index([urlNormalized])
  @@index([hash])
  @@index([impactScore])
  @@index([preFilterPassed])
  @@index([searchVectorEn], type: Gin)
}

enum ArticleStatus {
  PENDING
  FETCHED
  ENRICHED
  FAILED
  SKIPPED
}

model Enrichment {
  id                  String   @id @default(cuid())
  articleId           String   @unique
  article             Article  @relation(fields: [articleId], references: [id], onDelete: Cascade)
  titleTh             String?  // Optional - only for HIGH impact articles with Thai translation
  summaryTh           String?  // Optional - only for HIGH impact articles with Thai translation
  takeawaysTh         Json     // string[]
  tags                Json     // string[]
  sentiment           Sentiment
  marketImpact        MarketImpact
  hooksTh             Json     // string[]
  threadTh            Json     // string[]
  contentDraftTh      String?  // manual social post draft (article-style)
  cautions            Json?    // string[] optional
  mustQuote           Json?    // string[] optional
  finnhubSentiment    Json?    @map("finnhub_sentiment")  // Finnhub sentiment data
  fmpSentiment        Json?    @map("fmp_sentiment")      // FMP sentiment data
  sentimentConfidence Decimal? @db.Decimal(3,2) @map("sentiment_confidence")  // Aggregated confidence 0.00-1.00
  santimentMetrics    Json?    @map("santiment_metrics")  // On-chain metrics from Santiment
  metricsFetchedAt    DateTime? @map("metrics_fetched_at")  // When metrics were last fetched
  searchVectorTh      Unsupported("tsvector")? @map("search_vector_th")  // Full-text search vector for Thai
  llmModel            String
  llmProvider         String
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([sentiment])
  @@index([marketImpact])
  @@index([sentimentConfidence])
  @@index([metricsFetchedAt])
  @@index([searchVectorTh], type: Gin)
}

enum Sentiment {
  BULLISH
  BEARISH
  NEUTRAL
}

enum MarketImpact {
  HIGH
  MEDIUM
  LOW
}

model Posting {
  id               String        @id @default(cuid())
  articleId        String
  article          Article       @relation(fields: [articleId], references: [id], onDelete: Cascade)
  discordChannelId String
  discordMessageId String?
  postedAt         DateTime?
  status           PostingStatus @default(PENDING)
  postingType      String        @default("SUMMARY") @map("posting_type")  // SUMMARY or HIGH_IMPACT
  error            String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([articleId])
  @@index([discordChannelId])
  @@index([status])
  @@index([postedAt])
  @@index([postingType])
}

enum PostingStatus {
  PENDING
  POSTED
  FAILED
}

model JobAudit {
  id        String    @id @default(cuid())
  jobType   String
  articleId String?
  status    JobStatus
  error     String?
  metadata  Json?
  createdAt DateTime  @default(now())

  @@index([jobType])
  @@index([articleId])
  @@index([status])
  @@index([createdAt])
}

enum JobStatus {
  STARTED
  COMPLETED
  FAILED
}

model UserPost {
  id        String   @id @default(cuid())
  title     String   @default("Untitled")
  content   String
  imageUrl  String?
  published Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([published])
  @@index([createdAt])
}

model MarketSummary {
  id              String    @id @default(cuid())
  scheduleType    String    // 'morning' | 'evening'
  summaryText     String    // Thai market summary paragraph
  headlines       Json      // Array of { title, url, source } objects
  prices          Json      // { btc, eth, sol, hype, marketCap, fearGreed }
  articleCount    Int       // Number of articles included
  discordPosted   Boolean   @default(false)
  discordPostedAt DateTime?
  error           String?
  createdAt       DateTime  @default(now())

  @@index([scheduleType])
  @@index([createdAt])
}

model HighImpactQuota {
  id          String   @id @default(cuid())
  date        DateTime @unique @db.Date
  postedCount Int      @default(0) @map("posted_count")  // Number of high-impact posts today
  createdAt   DateTime @default(now()) @map("created_at")

  @@index([date])
  @@map("HighImpactQuota")
}

model EmergingMoverSnapshot {
  id               String               @id @default(cuid())
  status           String               @default("ok")
  signalTime       DateTime             @map("signal_time")
  totalMarkets     Int?
  scansInHistory   Int?
  hasImmediate     Boolean              @default(false) @map("has_immediate")
  hasEmergingMover Boolean              @default(false) @map("has_emerging_mover")
  hasDeepClimber   Boolean              @default(false) @map("has_deep_climber")
  top5             Json?
  rawPayload       Json                 @map("raw_payload")
  createdAt        DateTime             @default(now()) @map("created_at")
  alerts           EmergingMoverAlert[]

  @@index([signalTime])
  @@index([createdAt])
  @@map("EmergingMoverSnapshot")
}

model EmergingMoverAlert {
  id              String                @id @default(cuid())
  snapshotId      String                @map("snapshot_id")
  snapshot        EmergingMoverSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  signal          String
  direction       String?
  currentRank     Int?                  @map("current_rank")
  contribution    Decimal?              @db.Decimal(6,2)
  contribVelocity Decimal?              @map("contrib_velocity") @db.Decimal(8,4)
  traders         Int?
  priceChg4h      Decimal?              @map("price_chg_4h") @db.Decimal(8,2)
  reasonCount     Int                   @default(0) @map("reason_count")
  reasons         Json
  rankHistory     Json?                 @map("rank_history")
  contribHistory  Json?                 @map("contrib_history")
  isImmediate     Boolean               @default(false) @map("is_immediate")
  isDeepClimber   Boolean               @default(false) @map("is_deep_climber")
  erratic         Boolean               @default(false)
  lowVelocity     Boolean               @default(false) @map("low_velocity")
  createdAt       DateTime              @default(now()) @map("created_at")

  @@index([snapshotId])
  @@index([isImmediate])
  @@index([currentRank])
  @@index([createdAt])
  @@map("EmergingMoverAlert")
}

model OpportunitySnapshot {
  id             String              @id @default(cuid())
  scanTime       DateTime            @map("scan_time")
  assetsScanned  Int?                @map("assets_scanned")
  passedStage1   Int?                @map("passed_stage1")
  passedStage2   Int?                @map("passed_stage2")
  deepDived      Int?                @map("deep_dived")
  disqualified   Int?                @default(0)
  btcContext     Json?               @map("btc_context")
  rawPayload     Json                @map("raw_payload")
  createdAt      DateTime            @default(now()) @map("created_at")
  opportunities  OpportunitySignal[]

  @@index([scanTime])
  @@index([createdAt])
  @@map("OpportunitySnapshot")
}

model OpportunitySignal {
  id                String              @id @default(cuid())
  snapshotId        String              @map("snapshot_id")
  snapshot          OpportunitySnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  asset             String
  direction         String?
  leverage          Int?
  finalScore        Int?                @map("final_score")
  scoreDelta        Int?                @map("score_delta")
  scanStreak        Int?                @map("scan_streak")
  hourlyTrend       String?             @map("hourly_trend")
  trendAligned      Boolean             @default(false) @map("trend_aligned")
  pillarScores      Json?               @map("pillar_scores")
  smartMoney        Json?               @map("smart_money")
  technicals        Json?
  funding           Json?
  risks             Json?
  createdAt         DateTime            @default(now()) @map("created_at")

  @@index([snapshotId])
  @@index([asset])
  @@index([finalScore])
  @@index([createdAt])
  @@map("OpportunitySignal")
}

model WhaleSnapshot {
  id            String        @id @default(cuid())
  scanTime      DateTime      @map("scan_time")
  timeframe     String        @default("30d")
  candidates    Int?          @default(0)
  selectedCount Int?          @default(0) @map("selected_count")
  rawPayload    Json          @map("raw_payload")
  createdAt     DateTime      @default(now()) @map("created_at")
  traders       WhaleTrader[]

  @@index([scanTime])
  @@index([createdAt])
  @@map("WhaleSnapshot")
}

model WhaleTrader {
  id              String         @id @default(cuid())
  snapshotId      String         @map("snapshot_id")
  snapshot        WhaleSnapshot  @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  walletAddress   String         @map("wallet_address")
  score           Decimal?       @db.Decimal(6,2)
  rank            Int?
  consistency     String?
  riskLabel       String?        @map("risk_label")
  pnlRank         Int?           @map("pnl_rank")
  winRate         Decimal?       @map("win_rate") @db.Decimal(6,2)
  holdTimeHours   Decimal?       @map("hold_time_hours") @db.Decimal(10,2)
  maxDrawdownPct  Decimal?       @map("max_drawdown_pct") @db.Decimal(6,2)
  allocationPct   Decimal?       @map("allocation_pct") @db.Decimal(6,2)
  overlapRiskPct  Decimal?       @map("overlap_risk_pct") @db.Decimal(6,2)
  createdAt       DateTime       @default(now()) @map("created_at")

  @@index([snapshotId])
  @@index([walletAddress])
  @@index([score])
  @@index([rank])
  @@index([createdAt])
  @@map("WhaleTrader")
}
